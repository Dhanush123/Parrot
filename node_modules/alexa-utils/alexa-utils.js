var express = require('express');
var bodyParser = require('body-parser');
var verifier = require('alexa-verifier');
var deasync = require('deasync');

// used to verify that the incoming requests requests are comming from Amazon only
var requestVerifier = function(req, res, next) {
	if (!req.headers.signaturecertchainurl) {
		return next();
	}

	// mark the request body as already having been parsed so it's ignored by other body parser middlewares
	req._body = true;
	req.rawBody = '';
	req.on('data', function(data) {
		return req.rawBody += data;
	});
	req.on('end', function() {
		var cert_url, er, error, requestBody, signature;
		try {
			req.body = JSON.parse(req.rawBody);
		} catch (error) {
			er = error;
			req.body = {};
		}
		cert_url = req.headers.signaturecertchainurl;
		signature = req.headers.signature;
		requestBody = req.rawBody;
		verifier(cert_url, signature, requestBody, function(er) {
			if (er) {
				console.error('error validating the alexa cert:', er);
				res.status(401).json({
					status: 'failure',
					reason: er
				});
			} else {
				next();
			}
		});
	});
};

var utils = {}

utils.app = function(name) {
	var intents = {
		"LaunchRequest": undefined,
		"IntentRequest": {},
		"SessionEndedRequest": undefined
	};

	this.name = name;

	this.onLaunch = function(action) {
		intents["LaunchRequest"] = action;
		return this;
	}

	this.onIntent = function(intentName, action) {
		intents["IntentRequest"][intentName] = action;
		return this;
	}

	this.onSessionEnd = function(action) {
		intents["SessionEndedRequest"] = action;
		return this;
	}

	this.host = function(route, port, debug) {
		var server = express();

		if (arguments.length == 2) {
			debug = false;
		}
		
		//initialize with needed middleware
		if (!debug) {
			server.use(requestVerifier);
		}
		// not sure if we need this
		//server.use(bodyParser.json());
		//server.use(bodyParser.urlencoded({ extended: true }));

		// bind the app to the specified route
		server.post(route, function(req, res) {
			var request = req.body.request;
			var session = req.body.session;

			var newReq = {
				"intent": {
					"type": request.type
				},
				"session": {
					"new": session.new,
					"id": session.sessionId,
					"appId": session.application.applicationId,
					"getAttribute": function(name) {
						return session.attributes[name];
					},
					"user": {
						"id": session.user.userId,
						"accessToken": session.user.accessToken
					}
				}
			}

			var newRes = utils.response(res);

			switch (newReq.intent.type) {
				case "LaunchRequest":
					intents[newReq.intent.type](newReq, newRes);
					break;
				case "SessionEndedRequest":
					newReq.intent.reason = request.reason;
					intents[newReq.intent.type](newReq, newRes);
					break;
				case "IntentRequest":
					newReq.intent = {
						"name": request.intent.name,
						"slot": function(name) {
							return request.intent.slots[name].value;
						}
					}
					
					intents["IntentRequest"][newReq.intent.name](newReq, newRes);
					break;
			}
		});

		// start the server
		server.listen(port);
	}

	return this;
}

utils.response = function(res) {
	this.res = res;

	var tmpResponse = {
		"version": "1.0",
		"sessionAttributes": {},
		"response": {
			"shouldEndSession": true
		}
	}

	this.prompt = function(prompt) {
		if (prompt.startsWith("<speak>") && prompt.endsWith("</speak>")) {
			tmpResponse.response.outputSpeech = {
				"type": "SSML",
				"ssml": prompt
			};
		} else {
			tmpResponse.response.outputSpeech = {
				"type": "PlainText",
				"text": prompt
			};
		}
		
		return this;
	}

	this.reprompt = function(reprompt) {
		if (reprompt.startsWith("<speak>") && reprompt.endsWith("</speak>")) {
			tmpResponse.response.reprompt = {
				"outputSpeech": {
					"type": "SSML",
					"ssml": reprompt
				}
			};
		} else {
			tmpResponse.response.reprompt = {
				"outputSpeech": {
					"type": "PlainText",
					"text": reprompt
				}
			};
		}
		
		return this;
	}

	this.regularCard = function(title, textContent, smallImageUrl, largeImageUrl) {
		switch(arguments.length) {
			case 2:
				tmpResponse.response.card = {
					"type": "Simple",
					"title": title,
					"content": textContent,
				};
				break;
			case 3:
				tmpResponse.response.card = {
					"type": "Standard",
					"title": title,
					"text": textContent,
					"image": {
						"smallImageUrl": smallImageUrl
					}
				}
				break;
			case 4:
				tmpResponse.response.card = {
					"type": "Standard",
					"title": title,
					"text": textContent,
					"image": {
						"smallImageUrl": smallImageUrl,
						"largeImageUrl": largeImageUrl
					}
				}
				break;
		}

		return this;
	}

	this.linkAccountCard = function() {
		tmpResponse.response.card = {
			"type": "LinkAccount"
		};
		
		return this;
	}

	this.endSession = function(value) {
		tmpResponse.response.shouldEndSession = value;
		return this;
	}

	this.setAttribute = function(name, value) {
		tmpResponse.sessionAttributes[name] = value;
		return this;
	}

	this.send = function() {
		this.res.send(tmpResponse);
	}

	return this;
}

module.exports = utils;